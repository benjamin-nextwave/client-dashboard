---
phase: 04-instantly-ai-integration-campaign-stats
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260216000002_synced_leads_and_analytics.sql
  - src/lib/instantly/client.ts
  - src/lib/instantly/types.ts
  - src/lib/instantly/sync.ts
autonomous: true

must_haves:
  truths:
    - "synced_leads and campaign_analytics tables exist with RLS policies"
    - "Instantly API client can fetch campaign analytics and list leads"
    - "Sync function fetches from Instantly and upserts into Supabase"
  artifacts:
    - path: "supabase/migrations/20260216000002_synced_leads_and_analytics.sql"
      provides: "synced_leads and campaign_analytics tables with RLS and indexes"
      contains: "CREATE TABLE public.synced_leads"
    - path: "src/lib/instantly/client.ts"
      provides: "getCampaignAnalyticsOverview, getCampaignDailyAnalytics, listLeads functions"
      exports: ["listCampaigns", "getCampaignAnalyticsOverview", "getCampaignDailyAnalytics", "listLeads"]
    - path: "src/lib/instantly/types.ts"
      provides: "TypeScript interfaces for analytics, leads, and list responses"
      contains: "InstantlyLead"
    - path: "src/lib/instantly/sync.ts"
      provides: "syncClientData function that fetches from Instantly API and upserts to Supabase"
      exports: ["syncClientData"]
  key_links:
    - from: "src/lib/instantly/sync.ts"
      to: "src/lib/instantly/client.ts"
      via: "imports API functions"
      pattern: "import.*from.*instantly/client"
    - from: "src/lib/instantly/sync.ts"
      to: "src/lib/supabase/admin.ts"
      via: "uses admin client for INSERT/UPDATE (bypasses RLS)"
      pattern: "createAdminClient"
---

<objective>
Create the database tables and Instantly API sync infrastructure for Phase 4.

Purpose: All campaign stats and lead data must be stored locally in Supabase for fast aggregation queries. The Instantly API cannot aggregate across campaigns, so we sync data per-campaign and aggregate locally.

Output: Migration file with synced_leads + campaign_analytics tables, extended Instantly API client, and sync logic module.
</objective>

<execution_context>
@C:\Users\bstei\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bstei\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-instantly-ai-integration-campaign-stats/04-RESEARCH.md
@src/lib/instantly/client.ts
@src/lib/instantly/types.ts
@src/lib/supabase/admin.ts
@src/types/database.ts
@supabase/migrations/20260215000001_initial_schema.sql
@supabase/migrations/20260216000001_client_campaigns_and_storage.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for synced_leads and campaign_analytics</name>
  <files>supabase/migrations/20260216000002_synced_leads_and_analytics.sql</files>
  <action>
Create migration file with two tables following the schema from 04-RESEARCH.md:

**synced_leads table:**
- id UUID PK, client_id UUID FK to clients(id) ON DELETE CASCADE
- instantly_lead_id TEXT NOT NULL, campaign_id TEXT NOT NULL (internal only)
- email TEXT NOT NULL, first_name TEXT, last_name TEXT, company_name TEXT
- job_title TEXT, industry TEXT, company_size TEXT, website TEXT, phone TEXT
- lead_status TEXT (emailed, not_yet_emailed, replied, bounced)
- interest_status TEXT (positive, neutral, negative)
- sender_account TEXT (for INST-04 reply routing)
- email_sent_count INTEGER DEFAULT 0, email_reply_count INTEGER DEFAULT 0
- payload JSONB (raw custom variables from Instantly)
- last_synced_at TIMESTAMPTZ DEFAULT NOW(), created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(client_id, instantly_lead_id, campaign_id)
- Indexes: idx_synced_leads_client_id on (client_id), idx_synced_leads_interest on (client_id, interest_status)

**campaign_analytics table:**
- id UUID PK, client_id UUID FK to clients(id) ON DELETE CASCADE
- campaign_id TEXT NOT NULL (internal only)
- date DATE NOT NULL
- emails_sent INTEGER DEFAULT 0, leads_contacted INTEGER DEFAULT 0
- replies INTEGER DEFAULT 0, unique_replies INTEGER DEFAULT 0
- bounced INTEGER DEFAULT 0, opened INTEGER DEFAULT 0, clicked INTEGER DEFAULT 0
- last_synced_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(client_id, campaign_id, date)
- Index: idx_campaign_analytics_client_date on (client_id, date)

**RLS policies (follow existing pattern using `(SELECT auth.jwt())` subselect):**
- Both tables: ENABLE ROW LEVEL SECURITY
- Clients SELECT: WHERE client_id::TEXT = (SELECT auth.jwt() ->> 'client_id')
- Operators SELECT: WHERE (SELECT auth.jwt() ->> 'user_role') = 'operator'
- No INSERT/UPDATE/DELETE policies for authenticated users -- only service_role (admin client) writes

**Important:** campaign_id is internal-only and never exposed to client-facing queries. The RLS SELECT policies ensure clients only see their own data. Aggregation queries (in later plans) will GROUP BY client_id, never exposing campaign_id.
  </action>
  <verify>Run `npx supabase db diff` or check that the migration file has valid SQL syntax. Verify both CREATE TABLE statements, ENABLE ROW LEVEL SECURITY, all indexes, UNIQUE constraints, and 4 RLS policies (2 per table).</verify>
  <done>Migration file exists with synced_leads and campaign_analytics tables, both with RLS enabled, correct indexes, unique constraints, and SELECT-only policies for clients and operators.</done>
</task>

<task type="auto">
  <name>Task 2: Extend Instantly API client and create sync module</name>
  <files>src/lib/instantly/client.ts, src/lib/instantly/types.ts, src/lib/instantly/sync.ts</files>
  <action>
**Extend types.ts** -- add interfaces (keep existing InstantlyCampaign and InstantlyListResponse):
- `InstantlyCampaignAnalytics`: { sent, contacted, new_leads_contacted, opened, unique_opened, replies, unique_replies, bounced, clicked, unique_clicks }
- `InstantlyDailyAnalytics`: { date: string } + same fields as above
- `InstantlyLead`: { id, email, first_name, last_name, company_name, phone, website, status, status_summary, email_open_count, email_reply_count, email_click_count, payload: Record<string, unknown>, timestamp_created, timestamp_updated, last_step_from, last_step_id }

**Extend client.ts** -- add functions (keep existing listCampaigns):
- `getCampaignAnalyticsOverview(campaignIds: string[], startDate: string, endDate: string)` -- GET /campaigns/analytics/overview with ids, start_date, end_date params. Returns InstantlyCampaignAnalytics.
- `getCampaignDailyAnalytics(campaignId: string, startDate: string, endDate: string)` -- GET /campaigns/analytics/daily with campaign_id, start_date, end_date. Returns InstantlyDailyAnalytics[].
- `listLeads(campaignId: string, options?: { limit?: number; startingAfter?: string; interestStatus?: string })` -- POST /leads/list with body. Returns InstantlyListResponse<InstantlyLead>.

All functions use same pattern as existing listCampaigns: Bearer token auth, cache: 'no-store', throw on non-200. Extract shared BASE_URL and headers into constants at module top to avoid repetition.

**Create sync.ts** -- main sync orchestration:
- `syncClientData(clientId: string)` -- fetches all campaign IDs for the client from client_campaigns table (using admin client), then for each campaign: (1) fetch daily analytics and upsert into campaign_analytics, (2) fetch all leads with cursor pagination and upsert into synced_leads.
- Use admin client (createAdminClient) for all Supabase writes -- bypasses RLS for INSERT/UPDATE.
- Process campaigns sequentially (not parallel) to respect rate limits. Add 500ms delay between campaigns.
- For lead upsert: normalize ICP fields from payload -- check for common variants case-insensitively: job_title from payload["Job Title"] || payload["job_title"] || payload["Functie"]; industry from payload["Industry"] || payload["industry"] || payload["Branche"]; company_size from payload["Company Size"] || payload["company_size"] || payload["Bedrijfsgrootte"].
- Map lead_status from Instantly data: if email_reply_count > 0 -> "replied", elif status_summary contains "bounced" -> "bounced", elif email_sent_count > 0 -> "emailed", else -> "not_yet_emailed".
- Store sender_account from lead.last_step_from (INST-04).
- Use Supabase upsert with onConflict for both tables.
- `syncAllClients()` -- fetches all client IDs that have associated campaigns, calls syncClientData for each sequentially.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify client.ts exports getCampaignAnalyticsOverview, getCampaignDailyAnalytics, listLeads. Verify sync.ts exports syncClientData and syncAllClients.</verify>
  <done>Instantly API client has 3 new endpoint wrappers. Sync module can fetch from Instantly and upsert to Supabase with ICP normalization, lead status mapping, and rate limit-safe sequential processing.</done>
</task>

</tasks>

<verification>
- Migration file has valid SQL with 2 tables, 4+ RLS policies, 3+ indexes, 2 UNIQUE constraints
- TypeScript compiles cleanly
- sync.ts imports from client.ts and admin.ts correctly
- No campaign_id exposure in any client-facing code path
</verification>

<success_criteria>
Database tables ready for synced data. API client can fetch analytics and leads. Sync module can orchestrate the full sync flow per client. All code compiles without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-instantly-ai-integration-campaign-stats/04-01-SUMMARY.md`
</output>
