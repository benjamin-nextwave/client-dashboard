---
phase: 04-instantly-ai-integration-campaign-stats
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/cron/sync-instantly/route.ts
  - src/lib/data/campaign-stats.ts
autonomous: true

must_haves:
  truths:
    - "Cron endpoint triggers sync for all clients with campaigns"
    - "Data query helpers return aggregated stats per client from local tables"
  artifacts:
    - path: "src/app/api/cron/sync-instantly/route.ts"
      provides: "GET endpoint that triggers syncAllClients, protected by CRON_SECRET"
      exports: ["GET"]
    - path: "src/lib/data/campaign-stats.ts"
      provides: "All aggregation query functions for the dashboard"
      exports: ["getMonthlyStats", "getContactCount", "getContactStatusBreakdown", "getIndustryBreakdown", "getJobTitleBreakdown", "getUnansweredPositiveCount", "getPositiveLeadPatterns", "getContactList"]
  key_links:
    - from: "src/app/api/cron/sync-instantly/route.ts"
      to: "src/lib/instantly/sync.ts"
      via: "calls syncAllClients"
      pattern: "syncAllClients"
    - from: "src/lib/data/campaign-stats.ts"
      to: "synced_leads and campaign_analytics tables"
      via: "Supabase queries with client_id filtering"
      pattern: "from\\('synced_leads'\\)|from\\('campaign_analytics'\\)"
---

<objective>
Create the sync trigger endpoint and all data aggregation query helpers for the client dashboard.

Purpose: The cron endpoint enables periodic data sync from Instantly. The query helpers provide clean, typed functions that the dashboard UI components will call to get aggregated statistics -- never exposing campaign_id.

Output: Cron route handler and a comprehensive data access layer for campaign stats.
</objective>

<execution_context>
@C:\Users\bstei\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bstei\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-instantly-ai-integration-campaign-stats/04-RESEARCH.md
@.planning/phases/04-instantly-ai-integration-campaign-stats/04-01-SUMMARY.md
@src/lib/instantly/sync.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cron sync endpoint</name>
  <files>src/app/api/cron/sync-instantly/route.ts</files>
  <action>
Create a GET route handler at `/api/cron/sync-instantly` that:

1. Validates authorization: check for `Authorization: Bearer ${CRON_SECRET}` header. If CRON_SECRET env var is set and header doesn't match, return 401. This protects the endpoint in production (Vercel Cron sends the secret automatically).
2. Calls `syncAllClients()` from `src/lib/instantly/sync.ts`.
3. Returns JSON response: `{ success: true, timestamp: new Date().toISOString() }` on success.
4. Catches errors and returns `{ success: false, error: message }` with 500 status.
5. Add `export const dynamic = 'force-dynamic'` to prevent caching.

This endpoint will be called by Vercel Cron (configured in vercel.json) or manually by operators for testing. Do NOT create vercel.json yet -- that's a deployment concern for later.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify the route exports a GET function. Check that CRON_SECRET validation exists.</verify>
  <done>Cron endpoint exists at /api/cron/sync-instantly, validates CRON_SECRET, calls syncAllClients, returns success/error JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard data aggregation queries</name>
  <files>src/lib/data/campaign-stats.ts</files>
  <action>
Create a data access module with all aggregation query functions the dashboard needs. Each function takes a `clientId: string` parameter and uses `createClient()` from `@/lib/supabase/server` (NOT admin client -- uses RLS to enforce client_id filtering as defense-in-depth).

**Functions to create:**

1. `getMonthlyStats(clientId: string)` -- returns `{ totalReplies, positiveLeads, emailsSent }` for the current month.
   - totalReplies: SUM of replies from campaign_analytics WHERE date >= first day of current month
   - positiveLeads: COUNT DISTINCT email from synced_leads WHERE interest_status = 'positive' (note: this is all-time, showing leads marked positive -- "Geleverde leads deze maand" can filter by updated_at if needed, but research suggests using interest_status count)
   - emailsSent: SUM of emails_sent from campaign_analytics WHERE date >= first day of current month

2. `getUnansweredPositiveCount(clientId: string)` -- returns number (for "Reactie vereist" alert STAT-01).
   - COUNT DISTINCT email from synced_leads WHERE interest_status = 'positive' AND email_reply_count = 0
   - Note: Using email_reply_count = 0 as proxy for "unanswered" -- if Instantly shows 0 replies from the lead, operator hasn't engaged yet. This is a simplification; Phase 5 may refine with local reply tracking.

3. `getContactCount(clientId: string)` -- returns number (for "Contacten in database" STAT-04).
   - COUNT DISTINCT email from synced_leads (dedup across campaigns)

4. `getContactList(clientId: string)` -- returns array of contacts for the modal (STAT-04).
   - SELECT DISTINCT ON (email) email, first_name, last_name, company_name, job_title, industry, lead_status, interest_status FROM synced_leads ORDER BY email, updated_at DESC
   - This deduplicates across campaigns, keeping the most recently updated record

5. `getContactStatusBreakdown(clientId: string)` -- returns `{ status: string, count: number }[]` (STAT-06).
   - Group synced_leads by lead_status, COUNT DISTINCT email per status
   - Map lead_status to Dutch labels: emailed -> "Gemaild", not_yet_emailed -> "Nog niet gemaild", replied -> "Beantwoord", bounced -> "Gebounced"

6. `getIndustryBreakdown(clientId: string)` -- returns `{ name: string, value: number }[]` (STAT-07).
   - Group by COALESCE(industry, 'Onbekend'), COUNT DISTINCT email, ORDER BY count DESC, LIMIT 10

7. `getJobTitleBreakdown(clientId: string)` -- returns `{ name: string, value: number }[]` (STAT-08).
   - Group by COALESCE(job_title, 'Onbekend'), COUNT DISTINCT email, ORDER BY count DESC, LIMIT 10

8. `getPositiveLeadPatterns(clientId: string)` -- returns `{ industries: {name, value}[], jobTitles: {name, value}[] }` (STAT-09).
   - Same as industry/job title breakdown but filtered to interest_status = 'positive' only
   - This shows ICP patterns among leads that responded positively

All queries filter by client_id. Use Supabase query builder where possible; for complex aggregations that Supabase JS client cannot express, use `.rpc()` calls or raw SQL via a Supabase database function. However, try the query builder first -- `.select('lead_status').eq('client_id', clientId)` and then aggregate in TypeScript if the query builder doesn't support GROUP BY natively.

**Practical approach:** Since Supabase JS client does not support GROUP BY, fetch the relevant rows and aggregate in TypeScript. For large datasets, consider creating database functions later. For now, the dataset per client is manageable (hundreds to low thousands of leads).

Export all functions as named exports.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify all 8 functions are exported. Check that no function uses createAdminClient (should use server createClient for RLS).</verify>
  <done>All 8 query functions exist, typed, using server Supabase client with RLS. Functions aggregate data by client without exposing campaign_id.</done>
</task>

</tasks>

<verification>
- Cron endpoint compiles and exports GET
- All 8 data functions compile and are exported
- No campaign_id appears in any return type
- No createAdminClient usage in campaign-stats.ts (RLS enforced)
</verification>

<success_criteria>
Sync can be triggered via HTTP endpoint. All dashboard data needs are served by typed query functions that aggregate across campaigns without leaking campaign details.
</success_criteria>

<output>
After completion, create `.planning/phases/04-instantly-ai-integration-campaign-stats/04-02-SUMMARY.md`
</output>
