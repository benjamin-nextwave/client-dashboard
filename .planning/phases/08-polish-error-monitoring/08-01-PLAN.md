---
phase: 08-polish-error-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260215000010_error_logs.sql
  - src/lib/errors/log-error.ts
  - src/lib/instantly/sync.ts
  - src/lib/data/error-logs.ts
  - src/lib/actions/error-log-actions.ts
  - src/app/(operator)/admin/errors/page.tsx
  - src/app/(operator)/admin/errors/_components/error-log-table.tsx
  - src/app/(operator)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Operator can view an error monitoring dashboard showing API failures, import errors, and sync issues"
    - "Error dashboard displays client name, error type, timestamp, and resolution status"
    - "Operator can mark errors as resolved with timestamp and user tracking"
    - "Sync failures are automatically logged to the error_logs table"
  artifacts:
    - path: "supabase/migrations/20260215000010_error_logs.sql"
      provides: "error_logs table with RLS and indexes"
      contains: "CREATE TABLE public.error_logs"
    - path: "src/lib/errors/log-error.ts"
      provides: "logError utility function"
      exports: ["logError"]
    - path: "src/lib/data/error-logs.ts"
      provides: "Error log query functions"
      exports: ["getErrorLogs"]
    - path: "src/lib/actions/error-log-actions.ts"
      provides: "resolveError server action"
      exports: ["resolveError"]
    - path: "src/app/(operator)/admin/errors/page.tsx"
      provides: "Error monitoring dashboard page"
      contains: "force-dynamic"
    - path: "src/app/(operator)/admin/errors/_components/error-log-table.tsx"
      provides: "Interactive error log table with resolve buttons"
      contains: "use client"
  key_links:
    - from: "src/lib/instantly/sync.ts"
      to: "src/lib/errors/log-error.ts"
      via: "logError() calls in catch blocks"
      pattern: "logError\\("
    - from: "src/app/(operator)/admin/errors/page.tsx"
      to: "src/lib/data/error-logs.ts"
      via: "getErrorLogs() query"
      pattern: "getErrorLogs"
    - from: "src/app/(operator)/admin/errors/_components/error-log-table.tsx"
      to: "src/lib/actions/error-log-actions.ts"
      via: "resolveError server action"
      pattern: "resolveError"
    - from: "src/app/(operator)/layout.tsx"
      to: "/admin/errors"
      via: "nav link"
      pattern: "href.*admin/errors"
---

<objective>
Build the complete error monitoring system for operators (OADM-07).

Purpose: Operators currently have no visibility into sync failures, API errors, or import issues -- everything is silently console.error'd. This plan creates a new error_logs table, a logError utility, instruments existing sync code, and builds an operator-facing dashboard to view and resolve errors.

Output: Working error monitoring dashboard at /admin/errors with error logging infrastructure.
</objective>

<execution_context>
@C:\Users\bstei\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bstei\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-polish-error-monitoring/08-RESEARCH.md
@src/lib/supabase/admin.ts
@src/lib/instantly/sync.ts
@src/app/(operator)/layout.tsx
@src/app/(operator)/admin/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Error logs migration, logError utility, and sync instrumentation</name>
  <files>
    supabase/migrations/20260215000010_error_logs.sql
    src/lib/errors/log-error.ts
    src/lib/instantly/sync.ts
  </files>
  <action>
    1. Create migration `supabase/migrations/20260215000010_error_logs.sql`:
       - CREATE TABLE public.error_logs with columns: id (UUID PK DEFAULT gen_random_uuid()), client_id (UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE), error_type (TEXT NOT NULL CHECK IN ('api_failure', 'import_error', 'sync_error')), message (TEXT NOT NULL), details (JSONB), is_resolved (BOOLEAN NOT NULL DEFAULT FALSE), resolved_at (TIMESTAMPTZ), resolved_by (UUID REFERENCES auth.users(id)), created_at (TIMESTAMPTZ NOT NULL DEFAULT NOW())
       - ALTER TABLE ENABLE ROW LEVEL SECURITY
       - CREATE INDEX idx_error_logs_client_id ON client_id
       - CREATE INDEX idx_error_logs_created_at ON created_at DESC
       - CREATE INDEX idx_error_logs_unresolved ON is_resolved WHERE is_resolved = FALSE (partial index)
       - CREATE POLICY "Operators can manage error_logs" FOR ALL TO authenticated USING ((SELECT auth.jwt() ->> 'user_role') = 'operator') WITH CHECK ((SELECT auth.jwt() ->> 'user_role') = 'operator')

    2. Create `src/lib/errors/log-error.ts`:
       - Import createAdminClient from '@/lib/supabase/admin'
       - Define LogErrorInput interface: { clientId: string, errorType: 'api_failure' | 'import_error' | 'sync_error', message: string, details?: Record<string, unknown> }
       - Export async function logError(input: LogErrorInput): Promise<void>
       - Uses admin client (service_role) to insert into error_logs table
       - Entire function body wrapped in try/catch -- if logging itself fails, console.error and return silently. Never let error logging crash the parent operation.
       - Await the insert (do NOT fire-and-forget, per research pitfall 3 about serverless environments)

    3. Instrument `src/lib/instantly/sync.ts`:
       - Import logError from '@/lib/errors/log-error'
       - In syncClientData: the three existing catch/console.error blocks (analytics upsert error at ~line 154, analytics API error at ~line 161, leads upsert error at ~line 230, leads API error at ~line 238) -- add `await logError(...)` calls AFTER the existing console.error lines (keep console.error for local debugging)
       - For analytics upsert error: logError({ clientId, errorType: 'sync_error', message: `Analytics upsert mislukt voor campagne ${campaignId}`, details: { campaignId, error: analyticsError.message } })
       - For analytics API catch: logError({ clientId, errorType: 'api_failure', message: `Sync analytics mislukt voor campagne ${campaignId}`, details: { campaignId, error: error instanceof Error ? error.message : String(error) } })
       - For leads upsert error: logError({ clientId, errorType: 'sync_error', message: `Leads upsert mislukt voor campagne ${campaignId}`, details: { campaignId, error: leadsError.message } })
       - For leads API catch: logError({ clientId, errorType: 'api_failure', message: `Sync leads mislukt voor campagne ${campaignId}`, details: { campaignId, error: error instanceof Error ? error.message : String(error) } })
       - In syncAllClients: the catch block at ~line 274 -- add logError({ clientId, errorType: 'sync_error', message: `Volledige sync mislukt voor klant ${clientId}`, details: { error: error instanceof Error ? error.message : String(error) } })
  </action>
  <verify>
    Run `npx supabase db push --dry-run` or verify migration SQL is valid.
    Run `npx tsc --noEmit` to confirm no type errors.
    Grep sync.ts for "logError" -- should find 5 calls.
  </verify>
  <done>
    error_logs table migration exists with RLS operator-only policy and 3 indexes.
    logError utility silently logs errors via admin client.
    All 5 catch blocks in sync.ts now log to error_logs table in addition to console.error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Error monitoring dashboard page with resolve functionality</name>
  <files>
    src/lib/data/error-logs.ts
    src/lib/actions/error-log-actions.ts
    src/app/(operator)/admin/errors/page.tsx
    src/app/(operator)/admin/errors/_components/error-log-table.tsx
    src/app/(operator)/layout.tsx
  </files>
  <action>
    1. Create `src/lib/data/error-logs.ts`:
       - Import createAdminClient from '@/lib/supabase/admin'
       - Export async function getErrorLogs() that queries error_logs with foreign key join: `.select('*, clients(company_name)')` ordered by created_at DESC, limit 200
       - Return type should include the joined client company_name
       - Use admin client since this is operator-only

    2. Create `src/lib/actions/error-log-actions.ts`:
       - 'use server' directive
       - Import createClient from '@/lib/supabase/server' (for auth check), createAdminClient from admin
       - Export async function resolveError(errorId: string): Promise<{ success: true } | { error: string }>
       - Check auth: const supabase = await createClient(), get user, if no user return { error: 'Niet ingelogd.' }
       - Use admin client to update error_logs: set is_resolved = true, resolved_at = new Date().toISOString(), resolved_by = user.id, WHERE id = errorId
       - If update error, return { error: `Fout oplossen mislukt: ${error.message}` }
       - Call revalidatePath('/admin/errors') after successful update
       - Return { success: true }

    3. Create `src/app/(operator)/admin/errors/page.tsx`:
       - Export const dynamic = 'force-dynamic' (per project convention for admin pages)
       - Server component that calls getErrorLogs()
       - Page title: "Foutmonitoring" (h2, text-2xl font-bold)
       - Show count of unresolved errors as summary text under title
       - Pass errors data to ErrorLogTable client component

    4. Create `src/app/(operator)/admin/errors/_components/error-log-table.tsx`:
       - 'use client' directive
       - Receives errors array as prop (with client company_name from join)
       - Renders a table with columns: Klant (company_name), Type (error_type badge), Bericht (message, truncated), Datum (formatted with date-fns formatDistanceToNow or toLocaleDateString nl-NL), Status (Opgelost/Open badge)
       - Error type badges: api_failure = red "API fout", import_error = orange "Import fout", sync_error = yellow "Sync fout"
       - Status badges: is_resolved = green "Opgelost", !is_resolved = red "Open"
       - Each unresolved row has a "Oplossen" button that calls resolveError server action
       - Use useTransition for the resolve button to show pending state
       - Expandable details: clicking a row toggles showing the full message and JSON details below the row
       - Empty state: "Geen fouten gevonden" when no errors
       - Style consistent with admin page table (same Tailwind classes as /admin/page.tsx: rounded-lg border, divide-y, etc.)

    5. Update `src/app/(operator)/layout.tsx`:
       - Add navigation links between "NextWave Admin" title and "Uitloggen" button
       - Add a nav element with two links: "Klanten" (href="/admin") and "Fouten" (href="/admin/errors")
       - Style as simple text links with hover state, separated by a gap
       - Keep existing signOut form and overall header structure
       - Use Link from next/link for client-side navigation
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no type errors.
    Run `npm run build` to verify the page builds without errors.
    Verify /admin/errors page is accessible and renders the table structure.
  </verify>
  <done>
    Operator can navigate to /admin/errors via header nav link.
    Error dashboard shows table with client name, error type (Dutch badges), message, timestamp, and resolution status.
    Operator can click "Oplossen" to mark errors as resolved with timestamp tracking.
    Empty state shows "Geen fouten gevonden" when no errors exist.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. Migration SQL is syntactically valid
4. sync.ts contains 5 logError calls (grep count)
5. /admin/errors page renders with force-dynamic
6. Operator layout has nav links to both /admin and /admin/errors
</verification>

<success_criteria>
- error_logs table exists with operator-only RLS, 3 indexes
- logError utility writes to error_logs via admin client, never crashes parent
- All sync.ts catch blocks instrumented with logError
- Operator errors dashboard at /admin/errors shows error table with resolve functionality
- Operator header has navigation between Klanten and Fouten pages
- All Dutch labels: Foutmonitoring, Klant, Bericht, Datum, Status, Oplossen, Opgelost, Open
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-error-monitoring/08-01-SUMMARY.md`
</output>
